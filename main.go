package main

import (
	"crypto/tls"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/elazarl/goproxy"
)

const (
	DEFAULT_PORT = "8080"
	CERT_FILE    = "proxy.crt"
	KEY_FILE     = "proxy.key"
	COOKIE_LOG   = "cookies.log"
)

var (
	// Patterns untuk session cookies
	sessionPatterns = []*regexp.Regexp{
		regexp.MustCompile(`(?i)(session|sess|sid|auth|token|csrf|xsrf|jwt)`),
		regexp.MustCompile(`(?i)(cookie|login|remember|auth_token)`),
		regexp.MustCompile(`(?i)(bearer|refresh|access_token)`),
	}
)

func isSessionCookie(name string) bool {
	lowerName := strings.ToLower(name)
	for _, pattern := range sessionPatterns {
		if pattern.MatchString(lowerName) {
			return true
		}
	}
	return false
}

func logCookie(method, url, domain, name, value string, secure bool) {
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	secureFlag := "false"
	if secure {
		secureFlag = "true"
	}

	logEntry := fmt.Sprintf("[%s] %s %s | Domain: %s | %s=%s | Secure: %s",
		timestamp, method, url, domain, name, value, secureFlag)

	log.Println(logEntry)

	// Also log to file
	f, err := os.OpenFile(COOKIE_LOG, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Printf("Error opening log file: %v", err)
		return
	}
	defer f.Close()

	_, err = f.WriteString(logEntry + "\n")
	if err != nil {
		log.Printf("Error writing to log file: %v", err)
	}
}

func setupMITMCertificate() {
	// goproxy will auto-generate certificate if it doesn't exist
	// But we can also create our own if needed
	log.Println("MITM Certificate will be auto-generated by goproxy")
	log.Println("Browsers will show certificate warning - this is normal for MITM proxy")
}

func main() {
	// Setup MITM certificate
	setupMITMCertificate()

	// Get port from environment or use default
	port := os.Getenv("PROXY_PORT")
	if port == "" {
		port = DEFAULT_PORT
	}

	// Parse port as integer to validate
	if _, err := strconv.Atoi(port); err != nil {
		log.Fatalf("Invalid port number: %v", err)
	}

	// Create proxy
	proxy := goproxy.NewProxyHttpServer()
	proxy.Verbose = true // Enable verbose logging

	// Setup TLS certificate generation
	// goproxy will auto-generate certificates for each domain
	// MITM certificates will be created on-demand

	// Intercept requests and sniff cookies
	proxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {
		// Log request
		log.Printf("Request: %s %s", req.Method, req.URL.String())

		// Sniff cookies in request
		for _, cookie := range req.Cookies() {
			if isSessionCookie(cookie.Name) {
				logCookie(req.Method, req.URL.String(), req.URL.Host, cookie.Name, cookie.Value, cookie.Secure)
			}
		}

		return req, nil
	})

	// Intercept responses and sniff cookies
	proxy.OnResponse().DoFunc(func(res *http.Response, ctx *goproxy.ProxyCtx) *http.Response {
		// Log response
		if res != nil {
			log.Printf("Response: %s", res.Status)

			// Sniff cookies in Set-Cookie headers
			for _, cookie := range res.Cookies() {
				if isSessionCookie(cookie.Name) {
					logCookie("SET-COOKIE", ctx.Req.URL.String(), ctx.Req.URL.Host, cookie.Name, cookie.Value, cookie.Secure)
				}
			}

			// Also check for Set-Cookie headers directly
			setCookieHeaders := res.Header.Values("Set-Cookie")
			for _, setCookie := range setCookieHeaders {
				parts := strings.Split(setCookie, ";")
				if len(parts) > 0 {
					cookiePart := parts[0]
					equalsIndex := strings.Index(cookiePart, "=")
					if equalsIndex > 0 {
						cookieName := strings.TrimSpace(cookiePart[:equalsIndex])
						cookieValue := strings.TrimSpace(cookiePart[equalsIndex+1:])

						if isSessionCookie(cookieName) {
							// Check if secure
							secure := false
							for _, part := range parts[1:] {
								if strings.TrimSpace(strings.ToLower(part)) == "secure" {
									secure = true
									break
								}
							}
							logCookie("SET-COOKIE", ctx.Req.URL.String(), ctx.Req.URL.Host, cookieName, cookieValue, secure)
						}
					}
				}
			}
		}

		return res
	})

	// HTTPS CONNECT is handled automatically by goproxy
	// The proxy will automatically handle MITM for HTTPS connections

	// Setup TLS config for the proxy
	tlsConfig := &tls.Config{
		InsecureSkipVerify: true, // Allow self-signed certificates for MITM
	}

	// Start the proxy server
	log.Printf("üöÄ Session Cookie Sniffer Proxy starting on port %s", port)
	log.Printf("üìù Cookies will be logged to: %s", COOKIE_LOG)
	log.Printf("‚ö†Ô∏è  Browser will show certificate warnings - this is normal!")
	log.Printf("üìç Configure your browser to use this proxy: localhost:%s", port)
	log.Printf("\nPress Ctrl+C to stop the proxy\n")

	server := &http.Server{
		Addr:      ":" + port,
		Handler:   proxy,
		TLSConfig: tlsConfig,
	}

	err := server.ListenAndServe()
	if err != nil {
		log.Fatalf("Failed to start proxy server: %v", err)
	}
}
