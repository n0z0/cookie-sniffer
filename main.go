package main

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/elazarl/goproxy"
)

const (
	DEFAULT_PORT = "8080"
	CERT_FILE    = "proxy.crt"
	KEY_FILE     = "proxy.key"
	COOKIE_LOG   = "cookies.log"
)

var (
	// Patterns untuk session cookies - termasuk PHPSESSID
	sessionPatterns = []*regexp.Regexp{
		regexp.MustCompile(`(?i)(phpsessid|jsessionid|asp\.net_sessionid)`),
		regexp.MustCompile(`(?i)(session|sess|sid|auth|token|csrf|xsrf|jwt)`),
		regexp.MustCompile(`(?i)(cookie|login|remember|auth_token|bearer)`),
		regexp.MustCompile(`(?i)(refresh|access_token|oauth|apikey)`),
	}
)

func isSessionCookie(name string) bool {
	lowerName := strings.ToLower(name)

	// Special check for PHPSESSID (common PHP session cookie)
	if strings.Contains(strings.ToLower(name), "phpsessid") {
		log.Printf("[DEBUG] PHPSESSID detected: %s", name)
		return true
	}

	for _, pattern := range sessionPatterns {
		if pattern.MatchString(lowerName) {
			log.Printf("[DEBUG] Cookie '%s' matched pattern: %s", name, pattern.String())
			return true
		}
	}
	return false
}

func logCookie(method, url, domain, name, value string, secure bool) {
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	secureFlag := "false"
	if secure {
		secureFlag = "true"
	}

	logEntry := fmt.Sprintf("[%s] %s %s | Domain: %s | %s=%s | Secure: %s",
		timestamp, method, url, domain, name, value, secureFlag)

	log.Println(logEntry)

	// Also log to file
	f, err := os.OpenFile(COOKIE_LOG, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Printf("Error opening log file: %v", err)
		return
	}
	defer f.Close()

	_, err = f.WriteString(logEntry + "\n")
	if err != nil {
		log.Printf("Error writing to log file: %v", err)
	}
}

func setupMITMCertificate() {
	// goproxy will auto-generate certificate if it doesn't exist
	// But we can also create our own if needed
	log.Println("MITM Certificate will be auto-generated by goproxy")
	log.Println("Browsers will show certificate warning - this is normal for MITM proxy")
}

func main() {
	// Setup MITM certificate
	setupMITMCertificate()

	// Get port from environment or use default
	port := os.Getenv("PROXY_PORT")
	if port == "" {
		port = DEFAULT_PORT
	}

	// Parse port as integer to validate
	if _, err := strconv.Atoi(port); err != nil {
		log.Fatalf("Invalid port number: %v", err)
	}

	// Create proxy
	proxy := goproxy.NewProxyHttpServer()
	proxy.Verbose = true // Enable verbose logging

	// CRITICAL: Configure MITM for HTTPS CONNECT requests
	// This is the key fix - use HandleConnect with AlwaysMitm
	proxy.OnRequest().HandleConnect(goproxy.AlwaysMitm)

	// Basic request logging to verify handlers are working
	proxy.OnRequest().DoFunc(func(req *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {
		log.Printf("[DEBUG] Handler working! Request: %s %s", req.Method, req.URL.String())

		// Basic cookie checking
		if len(req.Cookies()) > 0 {
			log.Printf("[DEBUG] Found %d cookies in request", len(req.Cookies()))
			for _, cookie := range req.Cookies() {
				log.Printf("[DEBUG] Cookie: %s = %s", cookie.Name, cookie.Value)
				if isSessionCookie(cookie.Name) {
					log.Printf("[SUCCESS] Session cookie matched: %s", cookie.Name)
					logCookie(req.Method, req.URL.String(), req.URL.Host, cookie.Name, cookie.Value, cookie.Secure)
				}
			}
		}

		return req, nil
	})

	// Basic response logging
	proxy.OnResponse().DoFunc(func(res *http.Response, ctx *goproxy.ProxyCtx) *http.Response {
		log.Printf("[DEBUG] Handler working! Response: %s", res.Status)

		// Check for cookies in response
		if res != nil && len(res.Cookies()) > 0 {
			log.Printf("[DEBUG] Found %d cookies in response", len(res.Cookies()))
			for _, cookie := range res.Cookies() {
				log.Printf("[DEBUG] Response cookie: %s = %s", cookie.Name, cookie.Value)
				if isSessionCookie(cookie.Name) {
					log.Printf("[SUCCESS] Response session cookie matched: %s", cookie.Name)
					logCookie("SET-COOKIE", ctx.Req.URL.String(), ctx.Req.URL.Host, cookie.Name, cookie.Value, cookie.Secure)
				}
			}
		}

		return res
	})

	// Start the proxy server - use simple HTTP server since goproxy handles TLS internally
	log.Printf("üöÄ Session Cookie Sniffer Proxy starting on port %s", port)
	log.Printf("üìù Cookies will be logged to: %s", COOKIE_LOG)
	log.Printf("‚ö†Ô∏è  Browser will show certificate warnings - this is normal!")
	log.Printf("üìç Configure your browser to use this proxy: localhost:%s", port)
	log.Printf("‚úÖ HTTPS MITM is now enabled")
	log.Printf("")
	log.Printf("üîß DEBUGGING INFO:")
	log.Printf("   - Check console output for [DEBUG] messages")
	log.Printf("   - Look for [SUCCESS] messages when cookies are captured")
	log.Printf("   - Monitor [INFO] messages for unmatched cookies")
	log.Printf("   - Special support for PHPSESSID, JSESSIONID, ASP.NET_SessionId")
	log.Printf("")
	log.Printf("Press Ctrl+C to stop the proxy\n")

	// Start server - goproxy handles all the TLS/MITM complexity
	err := http.ListenAndServe(":"+port, proxy)
	if err != nil {
		log.Fatalf("Failed to start proxy server: %v", err)
	}
}
